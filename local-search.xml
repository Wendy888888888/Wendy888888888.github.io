<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hot100经典</title>
    <link href="/2025/03/24/hot100%E7%BB%8F%E5%85%B8/"/>
    <url>/2025/03/24/hot100%E7%BB%8F%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2024/11/01/%E8%B4%AA%E5%BF%83/"/>
    <url>/2024/11/01/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2024/11/01/%E5%9B%BE/"/>
    <url>/2024/11/01/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>图的模板code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>; <span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    vector&lt;Node*&gt; nexts;<span class="hljs-comment">//自己出度达到的点集</span><br>    vector&lt;Edge*&gt; edges;<span class="hljs-comment">//由自己出去的边集</span><br>    <span class="hljs-type">int</span> out;<span class="hljs-comment">//出度</span><br>    <span class="hljs-type">int</span> in;<span class="hljs-comment">//入度</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">value</span>(value), <span class="hljs-built_in">out</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">in</span>(<span class="hljs-number">0</span>) &#123;<br>        nexts = <span class="hljs-built_in">vector</span>&lt;Node*&gt;();<br>        edges = <span class="hljs-built_in">vector</span>&lt;Edge*&gt;();<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> weight;<br>    Node* from;<br>    Node* to;<br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> weight, Node* from, Node* to) : <span class="hljs-built_in">weight</span>(weight), <span class="hljs-built_in">from</span>(from), <span class="hljs-built_in">to</span>(to) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; nodes;<span class="hljs-comment">//&lt;索引，节点&gt; 一般索引==node.value;</span><br>    unordered_set&lt;Edge*&gt; edges;<br><br>    <span class="hljs-built_in">Graph</span>() : <span class="hljs-built_in">nodes</span>(<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">int</span>, Node*&gt;()), <span class="hljs-built_in">edges</span>(<span class="hljs-built_in">unordered_set</span>&lt;Edge*&gt;()) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>很多时候题目表示图的输入结构与模板并不同，这时候需要写接口函数。</p><p><strong>示例：</strong></p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241104224526937.png" alt="image-20241104224526937"></p><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241104224518360.png" alt="image-20241104224518360"></p><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241104224511975.png" alt="image-20241104224511975"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>入度为0的节点a，把a的出度边删除</p><p>再找现在入度为0的节点b……</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241104224428386.png" alt="image-20241104224428386"></p><h2 id="最小生成树（无向图）"><a href="#最小生成树（无向图）" class="headerlink" title="最小生成树（无向图）"></a>最小生成树（无向图）</h2><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730731272088.png" alt="构成环条件：from和to在一个集合中，如果不在就需要加上fromto边"></p><p>前期准备</p><p>（ps：可以用并查集代替）</p><p>每个node对应一个集合 MySets初始化刚开始每个node的集合只有它自己</p><p>union把from和to节点对应的集合全部合并到fromset里</p><p>kruskal(从边考虑，纳入最小边)</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241104231150770.png" alt="两个集合连通"></p><p>所以需要类似并查集的数据结构：</p><p>每个node对应一个集合 MySets初始化刚开始每个node的集合只有它自己</p><p>union把from和to节点对应的集合全部合并到fromset里</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730731799271.png" alt="1730731799271"></p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730733390616.png" alt="kruskal"></p><p>prim（从点考虑，找最小边）</p><p>每次拉进来一个点，数据结构要个哈希表就够了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2024/10/26/%E6%A0%91/"/>
    <url>/2024/10/26/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>常用写法：</p><p> s1.push(current-&gt;right);</p><p>current&#x3D;current-&gt;left</p><p>递归递推要有循环意识，走一遍循环知道每个循环都对节点做的操作</p>          </div><p><strong>递归序遍历</strong></p><p>先序遍历：遍历中第一次遇到每个结点时打印，之后再遇到不做操作</p><p>中二</p><p>后三</p><p><strong>非递归遍历</strong></p><p>先序</p><p>将头结点压栈</p><p>if (!current){return;}</p><p>while（栈不空）{</p><p>​弹出结点cur</p><p>​打印（处理）cur</p><p>​先压cur右孩子再压cur左孩子}</p><p>后序：要多用个收集栈逆序</p><p>if (!current){return;}</p><p>while（栈不空）{…}</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/332f8da6a4fc6095b4ff90d2e6ca20b.png" alt="后序非递归"></p><p>中序</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730010163040.png" alt="实质：靠左边界划分整棵树"></p><p>while(栈不空 <strong>|| current!&#x3D;nullptr</strong>） {</p><p>（1）一直压入所有左节点</p><p>（2）直到没左节点了弹出（打印）栈顶结点</p><p>（3）找cur的右结点：若有 循环跳至（1）      若没有 栈中再弹出一个结点（打印）循环至（1）</p><p>深度遍历–先序遍历</p><p>广度遍历：用队列</p><p>放入头结点</p><p>while（队列不空）{</p><p>弹出（打印）队头</p><p>若有左结点，压栈</p><p>若有右结点，压栈</p><p>}</p><p>求二叉树最大宽度</p><p>（设置map存储&lt;结点，结点的层数&gt;</p><p>每层结点数累计 </p><p>层数累计）</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730013541783.png" alt="1730013541783"></p><h2 id="遍历应用"><a href="#遍历应用" class="headerlink" title="遍历应用"></a>遍历应用</h2><p><strong>ps：在遍历程序里稍作改造</strong></p><h3 id="判断一棵树是否是搜索二叉树"><a href="#判断一棵树是否是搜索二叉树" class="headerlink" title="判断一棵树是否是搜索二叉树"></a>判断一棵树是否是搜索二叉树</h3><p>（中序遍历后数值从小到大）</p><p>法1 注意递归思想：其实每个结点都跟PreValue比较更新了</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730121023906.png"></p><p>法2 中序非递归 </p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730121415986.png" alt="1730121415986"></p><h3 id="判断一棵树是否为完全二叉树"><a href="#判断一棵树是否为完全二叉树" class="headerlink" title="判断一棵树是否为完全二叉树"></a>判断一棵树是否为完全二叉树</h3><p>宽度遍历</p><p>标准：1）任一节点有右孩子无左孩子 false</p><p>​2）如果遇到了第一个左右孩子不全  ，后续皆叶子节点</p><p>代码循环体走一遍就能看出 父节点（上一次循环）是不双全节点的节点居然还有孩子（不是叶节点） return false；</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730122036118.png" alt="1730122036118"></p><h3 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h3><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730452687591.png" alt="先序序列化和反序列化"></p><h2 id="二叉树递归结构套路"><a href="#二叉树递归结构套路" class="headerlink" title="二叉树递归结构套路"></a>二叉树递归结构套路</h2><div class="note note-success">            <p>此套路不适用于所有二叉树题目</p><p>书写代码逻辑：</p><p>1、返回值struct</p><p>2、process: 返回值1&#x3D;process(左子树)；</p><p>​                       返回值2&#x3D;process(右子树)；</p><p>​   递归返回的每个信息的求得</p><p>​   主函数的所有要求</p><p>​return 本轮返回值</p>          </div><h3 id="例1-判断是否是平衡二叉树"><a href="#例1-判断是否是平衡二叉树" class="headerlink" title="例1 判断是否是平衡二叉树"></a>例1 判断是否是平衡二叉树</h3><p><strong>主函数要求：</strong></p><p>左子树 是平</p><p>右子树 是平</p><p>|左树高度-右树高度|&lt;2</p><p><strong>如果为空返回什么</strong></p><p><strong>递归返回信息</strong>：（左子树右子树都需要）是否平衡 高度多少</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/e84e53b289a942637d365a9e0763376.png" alt="平衡balanced"></p><h3 id="例2-判断是否是搜索二叉树"><a href="#例2-判断是否是搜索二叉树" class="headerlink" title="例2 判断是否是搜索二叉树"></a>例2 判断是否是搜索二叉树</h3><p><strong>主函数要求：</strong></p><p>左子树 是BST</p><p>右子树 是BST</p><p>左子树max&lt;current&lt;右子树min</p><p><strong>如果为空返回什么</strong></p><p><strong>递归返回信息：</strong>（左子树右子树都需要）是否是BST，min，max</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/9a1ea1b81800a4680e09548f43a216f.png" alt="BST搜索"></p><h3 id="例3-判断是否是满二叉树"><a href="#例3-判断是否是满二叉树" class="headerlink" title="例3 判断是否是满二叉树"></a>例3 判断是否是满二叉树</h3><p><strong>主函数要求</strong>：</p><p>满足 节点数&#x3D;1&lt;&lt;data.height-1(2的height-1次方)</p><p><strong>如果为空返回什么</strong></p><p><strong>递归返回信息</strong>:高度 节点数</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/2fa36cef5c2d584dd9626949f27a663.png" alt="Full满二叉树"></p><h2 id="处理父节点"><a href="#处理父节点" class="headerlink" title="处理父节点"></a>处理父节点</h2><div class="note note-success">            <p>法1 用哈希map存储 fathermap（例：最近公共祖先）</p><p>法2 在struct node里添加node *parent;（例：后继节点）</p>          </div><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><p>一边从o1<strong>往父节点延伸</strong>（直到到达根节点），一边存入set。再从o2往父节点延伸，看看也没有set里的值</p><p>能往父节点延伸的前提是<strong>构建父子节点的哈希映射</strong></p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730432560748.png"></p><p>进递归是从根节点到叶节点一层层深入，然后一层层出递归的时候从叶节点往根节点上返。</p><h2 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h2><h3 id="x有右子树的时候-右子树的最左边节点"><a href="#x有右子树的时候-右子树的最左边节点" class="headerlink" title="x有右子树的时候 右子树的最左边节点"></a>x有右子树的时候 右子树的最左边节点</h3><p>x无右子树的时候 a.一路往上找，当节点是他父节点的左孩子时，父节点就是x的后继节点</p><p>​                              b.x是整棵树的最右节点 </p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730451258678.png"></p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1730525853430.png" alt="右子树最左节点"></p><h2 id="Huffman"><a href="#Huffman" class="headerlink" title="Huffman"></a>Huffman</h2><p>数据遍历用优先队列存储，buildtree的过程中build树形结构：</p><div class="note note-success">            <p>priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; pq;&#x2F;&#x2F;第一个值 结点，第二个值 优先队列底层存放结点的数据结构，第三个值 排序</p><p>优先队列-&gt;tree</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">HuffmanNode* left = pq.<span class="hljs-built_in">top</span>();<br>pq.<span class="hljs-built_in">pop</span>();<br>HuffmanNode* right = pq.<span class="hljs-built_in">top</span>();<br>pq.<span class="hljs-built_in">pop</span>();<br>sumEachTime = left-&gt;freq + right-&gt;freq;  <span class="hljs-comment">// 计算本次合并的频率和</span><br>HuffmanNode* parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HuffmanNode</span>(<span class="hljs-string">&#x27;$&#x27;</span>, sumEachTime);<span class="hljs-comment">//huffman编码中叶子结点都是用户的值，中间生成的值用&#x27;$&#x27;标记</span><br>  parent-&gt;left = left;<br> parent-&gt;right = right;<br> pq.<span class="hljs-built_in">push</span>(parent);<br></code></pre></td></tr></table></figure>          </div><p>无编码版的code如下：（光用huffman结构解决最小sum）</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241216010544292.png" alt="合并果子"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 哈夫曼树节点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HuffmanNode</span> &#123;<br>    <span class="hljs-type">int</span> freq;<br>    HuffmanNode* left;<br>    HuffmanNode* right;<br>    <span class="hljs-built_in">HuffmanNode</span>(<span class="hljs-type">int</span> f) :  <span class="hljs-built_in">freq</span>(f), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 用于优先队列比较的结构体，按照频率从小到大排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(HuffmanNode* a, HuffmanNode* b)</span> </span>&#123;<br>        <span class="hljs-comment">//返回true时a的优先级低</span><br>        <span class="hljs-keyword">return</span> a-&gt;freq &gt; b-&gt;freq;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 构建哈夫曼树，同时记录每次求和的值并累积</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">( <span class="hljs-type">int</span> n,vector&lt;<span class="hljs-type">int</span>&gt;&amp; freq, <span class="hljs-type">int</span>&amp; sumTotal)</span> </span>&#123;<br>    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; pq;<span class="hljs-comment">//第一个值 结点，第二个值 优先队列底层存放结点的数据结构，第三个值 排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt;n; ++i) &#123;<br>        HuffmanNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HuffmanNode</span>( freq[i]);<span class="hljs-comment">//把用户给的数据先放在优先队列</span><br>        pq.<span class="hljs-built_in">push</span>(newNode);<br>    &#125;<br><br>    <span class="hljs-type">int</span> sumEachTime = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用于记录每次合并时的频率和（求和的值）</span><br>    <span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>        HuffmanNode* left = pq.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//找最小</span><br>        pq.<span class="hljs-built_in">pop</span>();<br>        HuffmanNode* right = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br><br>        sumEachTime = left-&gt;freq + right-&gt;freq;  <span class="hljs-comment">// 计算本次合并的频率和</span><br>        sumTotal += sumEachTime;  <span class="hljs-comment">// 将本次的频率和累积到总的求和结果中</span><br><br>        HuffmanNode* parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HuffmanNode</span>( sumEachTime);<br>        parent-&gt;left = left;<br>        parent-&gt;right = right;<br><br>        pq.<span class="hljs-built_in">push</span>(parent);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sumTotal;<br>&#125;<br></code></pre></td></tr></table></figure><p>有编码（需要添加遍历和code存储）</p><p>遍历（使用干净的递归）</p><p>code存储与遍历对接 为了让遍历只是遍历，足够干净</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 哈夫曼树节点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HuffmanNode</span> &#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-type">int</span> freq;<span class="hljs-comment">//data的频率</span><br>    HuffmanNode* left;<br>    HuffmanNode* right;<br>    <span class="hljs-built_in">HuffmanNode</span>(<span class="hljs-type">char</span> ch, <span class="hljs-type">int</span> f) : <span class="hljs-built_in">data</span>(ch), <span class="hljs-built_in">freq</span>(f), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 用于优先队列比较的结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(HuffmanNode* a, HuffmanNode* b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a-&gt;freq &gt; b-&gt;freq;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 构建哈夫曼树，同时记录每次求和的值并累积</span><br><span class="hljs-function">HuffmanNode * <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; data, vector&lt;<span class="hljs-type">int</span>&gt;&amp; freq)</span> </span>&#123;<br>    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; pq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        HuffmanNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HuffmanNode</span>(data[i], freq[i]);<br>        pq.<span class="hljs-built_in">push</span>(newNode);<br>    &#125;<br><br>    <span class="hljs-type">int</span> sumEachTime = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用于记录每次合并时的频率和（求和的值）</span><br>    <span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//直至留在pq的最后一个根节点</span><br>        HuffmanNode* left = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        HuffmanNode* right = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br><br>        sumEachTime = left-&gt;freq + right-&gt;freq;  <span class="hljs-comment">// 计算本次合并的频率和</span><br>        HuffmanNode* parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HuffmanNode</span>(<span class="hljs-string">&#x27;$&#x27;</span>, sumEachTime);<span class="hljs-comment">//huffman编码中叶子结点都是用户的值，中间生成的值用&#x27;$&#x27;标记</span><br>        parent-&gt;left = left;<br>        parent-&gt;right = right;<br>        pq.<span class="hljs-built_in">push</span>(parent);<br>    &#125;<br><span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-comment">//递归体尽量简洁干净</span><br><span class="hljs-comment">// 生成哈夫曼编码的辅助函数，递归遍历哈夫曼树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generateCodes</span><span class="hljs-params">(HuffmanNode* root, string code, vector&lt;string&gt;&amp; codes)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;data!= <span class="hljs-string">&#x27;$&#x27;</span>) &#123;<span class="hljs-comment">//到达叶子节点需要记录code</span><br>        codes[root-&gt;data] = code;<br>    &#125;<br>    <span class="hljs-built_in">generateCodes</span>(root-&gt;left, code + <span class="hljs-string">&quot;0&quot;</span>, codes);<br>    <span class="hljs-built_in">generateCodes</span>(root-&gt;right, code + <span class="hljs-string">&quot;1&quot;</span>, codes);<br>&#125;<br><br><span class="hljs-comment">// 对外接口函数，用于获取哈夫曼编码</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getHuffmanCodes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; data, vector&lt;<span class="hljs-type">int</span>&gt;&amp; freq)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">codes</span><span class="hljs-params">(<span class="hljs-number">128</span>, <span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>    HuffmanNode*root =<span class="hljs-built_in">buildHuffmanTree</span>(data, freq);<br>    <span class="hljs-built_in">generateCodes</span>(root, <span class="hljs-string">&quot;&quot;</span>, codes);<br>    <span class="hljs-keyword">return</span> codes;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">char</span>&gt; data = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; freq = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>&#125;;<br>    <span class="hljs-built_in">buildHuffmanTree</span>(data, freq);<br>    vector&lt;string&gt; huffmanCodes = <span class="hljs-built_in">getHuffmanCodes</span>(data, freq);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; huffmanCodes[data[i]] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2024/10/20/%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/10/20/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="检验回文链表"><a href="#检验回文链表" class="headerlink" title="检验回文链表"></a>检验回文链表</h2><p>需要用到的数据结构：链表、栈</p><p>注意理解层面：n1、n2、n3都是指针，是把指针指向的地址赋给等号左侧的指针。每个指针都指向了一个地址，没有更换前一个地址可由多个指针同时指向。</p><p><strong>用栈</strong>（用额外空间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ishuiwenlink</span><span class="hljs-params">(listnode *head)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    listnode *p;<br>    p=head;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        s.<span class="hljs-built_in">push</span>(p-&gt;var);<br>        p=p-&gt;next;<br>    &#125;<br>    p=head;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp;!s.<span class="hljs-built_in">empty</span>()) &#123;<br><br>         <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">top</span>()!=p-&gt;var)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>         p=p-&gt;next;<br>         s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="链表补充"><a href="#链表补充" class="headerlink" title="链表补充"></a><strong>链表补充</strong></h2><p>打印链表函数，方便调试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">(listnode * head)</span></span>&#123;<br>    listnode *current =head;<br>    <span class="hljs-keyword">while</span> (current)&#123;<br>        cout&lt;&lt;(current-&gt;var);<br>        current=current-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>增，删：</p><p><strong>注意！！！</strong></p><div class="note note-success">            <p><strong>若想改变传进函数的指针的指向地址，必须用指针的指针&#x2F;引用</strong></p><p>删除链表元素记得考虑是不是头结点</p>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>&#123;<br><span class="hljs-type">int</span> var;<br>listnode* next;<br><span class="hljs-built_in">listnode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">var</span>(x),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br><br>&#125;;<br><span class="hljs-comment">//若想改变传进去的指针的指向地址，必须用指针的指针/引用</span><br><span class="hljs-comment">//头插法</span><br><span class="hljs-function">listnode* <span class="hljs-title">insertnode</span><span class="hljs-params">(<span class="hljs-type">int</span> x,listnode *&amp;head)</span></span>&#123;<br>    listnode *p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(x);<br>    p-&gt;next=head;<br>    head=p;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletenode</span><span class="hljs-params">(<span class="hljs-type">int</span> x,listnode *&amp;head)</span></span>&#123;<br>    listnode *p=head;<br>    listnode *temp;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-comment">//如果要删除的是头结点,不作为别人的next</span><br>        <span class="hljs-keyword">if</span>(head-&gt;var==x)&#123;<br>            head=p-&gt;next;<span class="hljs-comment">//可能改动头结点的指向</span><br><br>        &#125;<br>        <span class="hljs-comment">//不是头结点的情况</span><br>        <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">nullptr</span>&amp;&amp;p-&gt;next-&gt;var==x)&#123;<br>            temp=p-&gt;next;<span class="hljs-comment">//(保存待删除的结点地址用于清内存防止泄露)</span><br>            p-&gt;next=p-&gt;next-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        p=p-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反转链表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">listnode * <span class="hljs-title">reverselink</span><span class="hljs-params">( listnode *head)</span></span>&#123;<br><span class="hljs-comment">//初始化自己，前，后</span><br>    listnode *prev=<span class="hljs-literal">nullptr</span>;<br>    listnode *current;<br>    listnode *nextnode;<br>    current=head;<br>    <span class="hljs-comment">//循环体内：找到下一个结点，反连到前结点，自己赋给前，后赋给自己</span><br>    <span class="hljs-keyword">while</span>(current)&#123;<br>        nextnode=current-&gt;next;<br>        current-&gt;next=prev;<br>        prev=current;<br>        current=nextnode;<span class="hljs-comment">//转向原链表的下一个node</span><br>    &#125;<br>    <span class="hljs-comment">//出循环返回前指针</span><br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br><br></code></pre></td></tr></table></figure><div class="note note-success">            <p><strong>注意</strong>调用此函数的时候必须是：</p><p>printlist(reverselink(a));</p><p>因为他返回的是反转后链表的首结点，也是原链表的尾结点。</p><p>如果用printlist(a)；那就只剩一个结点可输出。</p>          </div><p>测试上述代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    listnode *a=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">//用insert方式构建以a为头结点的链表</span><br>    <span class="hljs-built_in">insertnode</span>(<span class="hljs-number">6</span>,a);<br>    <span class="hljs-built_in">insertnode</span>(<span class="hljs-number">7</span>,a);<br>    <span class="hljs-built_in">insertnode</span>(<span class="hljs-number">6</span>,a);<br>    cout&lt;&lt;<span class="hljs-built_in">ishuiwenlink</span>(a)&lt;&lt;endl;<br>    <span class="hljs-built_in">printlist</span>(a);<br>    <span class="hljs-built_in">printlist</span>(<span class="hljs-built_in">reverselink</span>(a));<span class="hljs-comment">//链表的结构已经被破坏</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1729910280345.png"></p><p><strong>前置基础准备</strong></p><p>有环单链表：找第一个入环结点</p><p><em>法1：unordered_set 如果同一个结点（同一个内存地址）出现第二次，则为第一个入环结点</em></p><p><em>问题：unordered_set<listnode> myset；不合法(&lt;&gt;里是基本数据类型）</em></p><p><em>法2：快慢指针</em></p><p>单链表如果出现环，就会绕在环里出不来（因为每个node只有一个next值）</p><p><strong>题目具体情况分析</strong></p><p>（1）返回两个无环单链表第一个相交的结点，不相交返回空</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1729909836333.png"></p><p>（2）一个链表有环一个链表无环：不可能相交 直接over</p><p>（3）两个有环链表三种情况：a.不相交 b.不在环相交 c.在环相交</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/0N">S%7B%25ZP%7DI1XY%60U7F%5D(JX%7D6.png)</p><p>情况b和(1)处理方式相同</p><p>从loop1(长链表入环结点)开始转一圈，如果遇到loop2就是情况c，如果没遇到就是情况a，返回null</p><p>综合上述写出主函数</p><p>根据上述思路手写的代码，但是由于测试样例比较复杂，所以没有通过codeblocks评测，只看看思路吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//指针形式表示链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>&#123;<br><span class="hljs-type">int</span> var;<br>listnode *next;<br><span class="hljs-built_in">listnode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">var</span>(x),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-function">listnode *<span class="hljs-title">findloop</span><span class="hljs-params">(listnode *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    listnode *slow = head;<br>    listnode *fast = head;<br>    <span class="hljs-keyword">while</span> (fast!= <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next!= <span class="hljs-literal">nullptr</span>) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            listnode *ptr = head;<br>            <span class="hljs-keyword">while</span> (ptr!= slow) &#123;<br>                ptr = ptr-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-comment">//两无环链表第一个交点</span><br><span class="hljs-function">listnode *<span class="hljs-title">jiaodian</span><span class="hljs-params">(listnode *head1,listnode *head2)</span></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    listnode *p=head1;<br>    listnode *q=head2;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            n++;<br><br>    &#125;<span class="hljs-comment">//出循环时p是endnode</span><br>    <span class="hljs-keyword">while</span>(q-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>        n--;<br>    &#125;<br>    n=<span class="hljs-built_in">abs</span>(n);<br>    p=head1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>((p!=q)&amp;&amp; (p-&gt;next=<span class="hljs-literal">nullptr</span>) &amp;&amp; (q-&gt;next=<span class="hljs-literal">nullptr</span>))&#123;<br>        p=p-&gt;next;<br>        q=q-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br><br>&#125;<br><span class="hljs-comment">//两个有环情况ac</span><br><span class="hljs-function">listnode *<span class="hljs-title">ac</span><span class="hljs-params">(listnode *head1,listnode*head2,listnode*loop1,listnode *loop2)</span></span>&#123;<br><span class="hljs-comment">//让指针达到loop1的位置</span><br>listnode *p=loop1-&gt;next;<br><span class="hljs-keyword">while</span> (p!=loop1)&#123;<br>    <span class="hljs-keyword">if</span> (p==loop2)&#123;<br>        <span class="hljs-keyword">return</span> loop2;<br>    &#125;<br>    p=p-&gt;next;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    listnode * head1;<br>    listnode *head2;<br>    listnode *loop1;<br>    listnode *loop2;<br>    listnode *result;<br>    loop1=<span class="hljs-built_in">findloop</span>(head1);<br>    loop2=<span class="hljs-built_in">findloop</span>(head2);<br>    <span class="hljs-comment">//两个有环ac</span><br>    <span class="hljs-keyword">if</span>(loop1 &amp;&amp; loop2 &amp;&amp;loop1!=loop2)&#123;<br>     result=<span class="hljs-built_in">ac</span>(head1,head2,loop1,loop2);<br>    <span class="hljs-keyword">if</span> (result!=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> result-&gt;var;<br>    &#125; <span class="hljs-keyword">else</span> &#123;cout&lt;&lt;<span class="hljs-string">&quot;null&quot;</span>;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    &#125;<br>    <span class="hljs-comment">//两个无环或者两个有环b</span><br>   <span class="hljs-keyword">if</span> ((!loop1 &amp;&amp; !loop2 )|| (loop1&amp;&amp;loop2&amp;&amp;(loop1==loop2)))&#123;<br>       result=<span class="hljs-built_in">jiaodian</span>(head1,head2);<br>        <span class="hljs-keyword">return</span> result-&gt;var;<br>    &#125;<br>   cout&lt;&lt;<span class="hljs-string">&quot;null&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>oj打开方式</title>
    <link href="/2024/10/05/oj%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/10/05/oj%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p><strong>万能头：#include &lt;bits&#x2F;stdc++.h&gt;</strong>  </p><div class="note note-success">            <ol><li><p>%s 表示字符串。</p></li><li><p>%c 表示字符。</p></li><li><p>%lf 表示双精度浮点数 ( double )。</p></li><li><p>%lld 表示长整型 ( long long )。  </p></li><li><p>%llu 表示无符号长整型 ( unsigned long long )， 无符号整数不能读<br>入负数  </p></li><li><p>return 的巧妙放置可以自如切断程序</p></li><li><p>如果数据范围超了Int就开long long  #define int long long(把下文所有Int替换成long long 不过long long开完耗时)</p></li></ol>          </div><p><strong>输入情况1</strong>：若干个数字，最后一个数字是 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin &gt;&gt; n)<br>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//0的时候结束循环</span><br><span class="hljs-keyword">else</span><br>&#123;<br> 做别的操作<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输入情况2</strong>：需要读有空格的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">getline</span>(cin,str);<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = str.<span class="hljs-built_in">length</span>();<br></code></pre></td></tr></table></figure><p><strong>输入情况3</strong>：需要忽略空格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin &gt;&gt; str) &#123;<br>cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>字符串转化为数字</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string t;<br><span class="hljs-built_in">getline</span>(cin,t);<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">stoi</span>(t);<span class="hljs-comment">//将字符串转化为数字</span><br></code></pre></td></tr></table></figure><p><em>数字转化为字符串</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>string t;<br>cin &gt;&gt; n;<br>t = <span class="hljs-built_in">to_string</span>(n);<br></code></pre></td></tr></table></figure><p><strong>控制输出精度：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">9</span>) &lt;&lt; your_number &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>myVector.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// 在vector末尾添加一个新的整数6</span><br>myVector.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除最后一个元素  </span><br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除第二个元素（基于0的索引）  </span><br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>(), myVector.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>); <span class="hljs-comment">// 删除前两个元素</span><br><span class="hljs-type">size_t</span> vectorSize = myVector.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><p>遍历容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = myVector.<span class="hljs-built_in">begin</span>(); it != myVector.<span class="hljs-built_in">end</span>(); ++it) &#123;  <br>  cout &lt;&lt; *it &lt;&lt; endl;  <br>&#125;  <br><span class="hljs-comment">// 或者使用范围for循环  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : myVector) &#123;  <br>    cout &lt;&lt; num &lt;&lt; endl;  <br>&#125;<br></code></pre></td></tr></table></figure><p>删除所有target值的元素：（循环+it迭代器+erase)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); it!= vec.<span class="hljs-built_in">end</span>(); )<br> &#123;<br>    <span class="hljs-keyword">if</span> (*it == target)<br>   &#123;it = vec.<span class="hljs-built_in">erase</span>(it);<span class="hljs-comment">//此时 erase 操作会返回一个新的迭代器指向被删除元素之后的那个元素</span><br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>        ++it;<br>      &#125;<br>&#125;<br><span class="hljs-comment">//测试验证</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec)<br> &#123;std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>删除第一个等于target值：不加循环 找到第一个删了就结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), target);<br><span class="hljs-keyword">if</span> (it!= vec.<span class="hljs-built_in">end</span>())<br>&#123;<br>  vec.<span class="hljs-built_in">erase</span>(it);<br>&#125;<br><span class="hljs-comment">//测试验证</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec)<br>&#123;std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><p>处理复数等成对数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">double</span>&gt;&gt;<span class="hljs-built_in">modules</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin&gt;&gt;modules[i].first&gt;&gt;modules[i].second;<br>&#125;<br><span class="hljs-comment">//double a = modules[i].first, b = modules[i].second;</span><br><span class="hljs-comment">//double c = modules[j].first, d = modules[j].second;</span><br></code></pre></td></tr></table></figure><h3 id="vectorVS-hashmap"><a href="#vectorVS-hashmap" class="headerlink" title="vector&lt;pair&lt;double, double&gt;&gt;VS hashmap"></a>vector&lt;pair&lt;double, double&gt;&gt;VS hashmap</h3><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/_I%7DXJ%5D5V%25Q4%7DD%60HJPQG0%7EPY.png" alt="区别"></p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250312212908582.png" alt="转换"></p><h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p>其中rand()能生成一个0到<code>RAND_MAX</code>（通常是32767）之间的随机数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> min = <span class="hljs-number">1</span>;  <br><span class="hljs-type">int</span> max = <span class="hljs-number">100</span>;  <br><span class="hljs-type">int</span> range_random_number = min + <span class="hljs-built_in">rand</span>() % (max - min + <span class="hljs-number">1</span>);  <br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br>stack&lt;<span class="hljs-type">int</span>&gt;s;<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//压栈</span><br>s.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//弹栈</span><br><span class="hljs-type">int</span> element = s.<span class="hljs-built_in">top</span>()<span class="hljs-comment">//访问栈顶不移除</span><br><span class="hljs-type">size_t</span> stacksize=s.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出</p><p>尾进头出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>queue &lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//尾部添加元素</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">9</span>);<span class="hljs-comment">//尾部添加元素</span><br>cout&lt;&lt;q.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<span class="hljs-comment">//统计大小</span><br>cout&lt;&lt;q.<span class="hljs-built_in">front</span>()&lt;&lt;endl;<span class="hljs-comment">//查看队列前端元素（不移除）</span><br>cout&lt;&lt;q.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<span class="hljs-comment">//查看队列后端元素（不移除）</span><br>q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//砍头</span><br>cout&lt;&lt;q.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="priority-queue（堆）"><a href="#priority-queue（堆）" class="headerlink" title="priority queue（堆）"></a>priority queue（堆）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用于优先队列比较的结构体，按照频率从小到大排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(HuffmanNode* a, HuffmanNode* b)</span> </span>&#123;<br>        <span class="hljs-comment">//返回true时a的优先级低</span><br>        <span class="hljs-keyword">return</span> a-&gt;freq &gt; b-&gt;freq;<br>    &#125;<br>&#125;;<br>priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; pq;<span class="hljs-comment">//第一个值 结点，第二个值 优先队列底层存放结点的数据结构，第三个值 排序</span><br><span class="hljs-type">int</span> lowestPriorityElement = pq.<span class="hljs-built_in">top</span>();<br>pq.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//题目：找出前k个高频元素</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br> unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mymap;<br> vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span> (mymap.<span class="hljs-built_in">count</span>(nums[i])==<span class="hljs-number">0</span>)&#123;<br>        mymap.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>    &#125;<span class="hljs-keyword">else</span>&#123;mymap[nums[i]]++;&#125;<span class="hljs-comment">//建map的时候first second只能这么确定 但是后续排序用second</span><br> &#125;<br> priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;maxHeap;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;pair:mymap)&#123;<br>    maxHeap.<span class="hljs-built_in">push</span>(&#123;pair.second,pair.first&#125;);<span class="hljs-comment">//默认用第一个值排序</span><br> &#125;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    result.<span class="hljs-built_in">push_back</span>(maxHeap.<span class="hljs-built_in">top</span>().second);<br>    maxHeap.<span class="hljs-built_in">pop</span>();<br><br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表都是常数级的查询</p><h3 id="哈希map"><a href="#哈希map" class="headerlink" title="哈希map"></a>哈希map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; myMap;  <span class="hljs-comment">//键是string，key是int</span><br><span class="hljs-comment">// 插入键值对</span><br>myMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">5</span>;<br>myMap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">3</span>;<br>myMap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">7</span>;<br><span class="hljs-comment">//法2：auto result = myMap.insert(&#123;&quot;one&quot;，1&#125;);  </span><br><span class="hljs-comment">//访问result.second （first指向该键值对的位置，second说明插入成功与否的布尔值）</span><br><br><span class="hljs-comment">//访问值</span><br>cout&lt;&lt;myMap.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;apple&quot;</span>)&lt;&lt;endl;<br><span class="hljs-comment">//删除</span><br>myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;banana&quot;</span>);<br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;pair:myMap)&#123;<br>    cout&lt;&lt;pair.first&lt;&lt;endl;<br>    cout&lt;&lt;pair.second&lt;&lt;endl;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>哈希表通常用键取值，不像pair对里面用<strong>数组索引</strong>查询成对值，pair示例如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">vector&lt;pair&lt;double,double&gt;&gt;<span class="hljs-built_in">fushu</span>(n);<br><span class="hljs-built_in">for</span>(int i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin&gt;&gt;modules<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.first</span>&gt;&gt;modules<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.second</span>;<br>&#125;<br><span class="hljs-comment">//double a = modules[i].first, b = modules[i].second;</span><br><span class="hljs-comment">//double c = modules[j].first, d = modules[j].second;</span><br></code></pre></td></tr></table></figure><h3 id="哈希set"><a href="#哈希set" class="headerlink" title="哈希set"></a>哈希set</h3><p>set无重复元素，也没有数组一样的索引，但是能用迭代器遍历所有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt;myset;<span class="hljs-comment">//不含重复元素</span><br>    myset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>);<br>    myset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">9</span>);<br>    <span class="hljs-keyword">if</span>(myset.<span class="hljs-built_in">count</span>(<span class="hljs-number">6</span>))&#123;cout&lt;&lt;<span class="hljs-string">&quot;元素存在&quot;</span>&lt;&lt;endl;&#125;<br><br>    myset.<span class="hljs-built_in">erase</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem:myset)&#123;<br>        cout&lt;&lt;elem&lt;&lt;endl;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当你使用 insert 方法向 set 中插入一个元素时，insert 方法会返回一个pair，其中：</p><p>first 是一个指向 set 中插入位置（或等效位置，如果元素已存在）的迭代器。<br>second 是一个布尔值，指示插入是否成功。如果元素已存在于 set 中，second 将为 false；否则，second 将为 true。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> result = mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">//注意result一定是由insert返回的</span><br>   <span class="hljs-keyword">if</span> (result.second) &#123;  <br>       std::cout &lt;&lt; <span class="hljs-string">&quot;Insertion successful, value 5 added.&quot;</span> &lt;&lt; std::endl;  <br>   &#125; <span class="hljs-keyword">else</span> &#123;  <br>       std::cout &lt;&lt; <span class="hljs-string">&quot;Insertion failed, value 5 already exists.&quot;</span> &lt;&lt; std::endl;  <br>   &#125;  <br> <br></code></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt;mylist=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>mylist.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>it是指针，可以用它在指定位置插入，删除指定位置元素，遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">it =mylist.<span class="hljs-built_in">begin</span>();<br><span class="hljs-built_in">advance</span>(it,<span class="hljs-number">3</span>);<span class="hljs-comment">//移动到第四个元素</span><br>mylist.<span class="hljs-built_in">insert</span>(it,<span class="hljs-number">99</span>);<span class="hljs-comment">//第四个元素前加上99</span><br>mylist.<span class="hljs-built_in">erase</span>(it);<span class="hljs-comment">//删除第四个元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it =mylist.<span class="hljs-built_in">begin</span>();it!=mylist.<span class="hljs-built_in">end</span>(),it++)&#123;<br>    cout&lt;&lt;*it&lt;&lt;endl;<br>&#125;<br>mylist.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//删除所有值为 2 的元素  </span><br></code></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大（栈顶到栈底递增）或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250322122131476.png" alt="下一个比i更高温度在几天后"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>1.需不需要返回值</p><p>2.如果需要返回值 是搜索一条边还是整棵树</p><p>3.找公共祖先 自底向上 用后序遍历</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250309165901226.png" alt="找最近公共祖先思考过程"></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>五要素中的遍历顺序要看递推式是哪里的数据递推出来的：</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250309192239338.png" alt="image-20250309192239338"></p><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>写法1：即dp[i] [j]  表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>物品背包谁先谁后不重要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写法2：初始化0</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>外正序内j size倒序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意滚动数组dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);的写法，<strong>旨在dp[j]却要在i,j双遍历下找最大或者最小值时。</strong></p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><ol><li>dp[i] [j]：可选0-i下标的物品，填充j背包空间的最大价值。</li><li>递推公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);</code></li></ol><p>（注意，完全背包二维dp数组 和 01背包二维dp数组 递推公式的区别，01背包中是 <code>dp[i - 1][j - weight[i]] + value[i])</code>）</p><p>​3.初始化 根据递推公式 对j的初始化：背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250324005015312.png" alt="初始化i"></p><p>二维dp遍历，顺序是从小到大 内外层随便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>用堆排序解决在给定数组nums中返回第k个最大的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapfy</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> heapsize)</span></span>&#123;<br>    <span class="hljs-type">int</span> largest;<br>    <span class="hljs-keyword">while</span>(index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;heapsize)&#123;<span class="hljs-comment">//下方有孩子</span><br>        <span class="hljs-keyword">if</span>(index*<span class="hljs-number">2</span><span class="hljs-number">+2</span>&lt;heapsize)&#123;<br>           <span class="hljs-type">int</span> a=arr[index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&gt;arr[index*<span class="hljs-number">2</span><span class="hljs-number">+2</span>]?(index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>):(index*<span class="hljs-number">2</span><span class="hljs-number">+2</span>);<br>            largest=arr[a]&gt;arr[index]?a:index;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        largest=arr[index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&gt;arr[index]?(index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>):index;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(largest==index)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">swap</span>(arr[largest],arr[index]);<br>        index=largest;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-type">int</span> heapsize = arr.<span class="hljs-built_in">size</span>();<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=heapsize<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-built_in">heapfy</span>(arr,i,heapsize);<br> &#125;<br><br> <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">1</span>)&#123;<br>     <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>],arr[heapsize<span class="hljs-number">-1</span>]);<br> heapsize--;<br> k--;<br> <span class="hljs-built_in">heapfy</span>(arr,<span class="hljs-number">0</span>,heapsize);<br> &#125;<br> <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>给定nums数组和整数k，返回出现频率前k高的元素。</p><p>法1：unordered_map&lt;int,int&gt;和vector&lt;pair&lt;int,int&gt;&gt;可以转化 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br> unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mymap;<br> vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span> (mymap.<span class="hljs-built_in">count</span>(nums[i])==<span class="hljs-number">0</span>)&#123;<br>        mymap.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>    &#125;<span class="hljs-keyword">else</span>&#123;mymap[nums[i]]++;&#125;<span class="hljs-comment">//建map的时候first second只能这么确定 但是后续排序用second</span><br> &#125;<br><span class="hljs-comment">//想用哈希映射的second来排序，那就把哈希映射放到数组里</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; freqPairs;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : mymap) &#123;<br>            freqPairs.<span class="hljs-built_in">push_back</span>(pair);<br>        &#125;<br><br>        <span class="hljs-comment">// 按频率降序排序</span><br>        <span class="hljs-built_in">sort</span>(freqPairs.<span class="hljs-built_in">begin</span>(), freqPairs.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> b.second &lt; a.second; <span class="hljs-comment">// 降序</span><br>        &#125;);<br><br>        <span class="hljs-comment">// 取前k个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(freqPairs[i].first);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>法2：用优先队列（堆）api:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//调用c++堆api的写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br> unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mymap;<br> vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span> (mymap.<span class="hljs-built_in">count</span>(nums[i])==<span class="hljs-number">0</span>)&#123;<br>        mymap.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>    &#125;<span class="hljs-keyword">else</span>&#123;mymap[nums[i]]++;&#125;<span class="hljs-comment">//建map的时候first second只能这么确定 但是后续排序用second</span><br> &#125;<br> priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;maxHeap;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;pair:mymap)&#123;<br>    maxHeap.<span class="hljs-built_in">push</span>(&#123;pair.second,pair.first&#125;);<br> &#125;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    result.<span class="hljs-built_in">push_back</span>(maxHeap.<span class="hljs-built_in">top</span>().second);<br>    maxHeap.<span class="hljs-built_in">pop</span>();<br><br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><strong>作用：</strong>join函数理解上是有向边 但是做题直接用于无向图简单（用有向边绕结果一致） 但是有向图比较复杂</p><p><a href="https://programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html#%E6%80%9D%E8%B7%AF</a></p><p>代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩，用father承接find返回值 u直接连到根节点</span><br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u的根节点 加入并查集</span><br><span class="hljs-comment">//find函数的路径压缩在此处也会有体现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>1-n结点的路径</p><p><strong>邻接表写法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[x]) &#123; <span class="hljs-comment">// 找到 x指向的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    &#125;<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br></code></pre></td></tr></table></figure><p><strong>邻接矩阵写法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>        <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 找到 x链接的节点</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span><br>        graph[s][t] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br></code></pre></td></tr></table></figure><p><strong>计算岛屿数量</strong></p><p>深搜版：结束条件暗含在越界continue之后不再调用dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 没有访问过的 同时 是陆地的</span><br><br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>广搜版（广搜本来是适合找最短路径）</p><p>注意是压入队列的时候标记visited数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) &#123;<br>                que.<span class="hljs-built_in">push</span>(&#123;nextx, nexty&#125;);<br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">bfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>前中后序遍历首推递归，其次迭代（前后迭代类同，中序迭代法需要添加指针访问）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前序递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250320111542136.png" alt="后序迭代思路"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//后序迭代</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left); <span class="hljs-comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 空节点不入栈</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将结果反转之后就是左右中的顺序了</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>中序迭代是特例 单独记忆：</p><p>ps：只有中序会  while (cur !&#x3D; NULL || !st.empty()) ，其他while一般只要栈&#x2F;队列非空即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>层序遍历首推队列，其次递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-comment">//每一轮while是遍历一层</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树搜索某值"><a href="#二叉搜索树搜索某值" class="headerlink" title="二叉搜索树搜索某值"></a>二叉搜索树搜索某值</h3><p>递归的返回值要<strong>接住</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        TreeNode* result = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeight</span>(root) == <span class="hljs-number">-1</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>构造前缀和矩阵，再用该矩阵查询子矩阵的元素和</p><p>注意：<img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20250323180130278.png" alt="注意事项"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 计算二维前缀和</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computePrefixSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prefixSum)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cols = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 初始化前缀和数组，大小为 (rows + 1) x (cols + 1)</span><br>    prefixSum.<span class="hljs-built_in">resize</span>(rows + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(cols + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; ++j) &#123;<br>            <span class="hljs-comment">// prefixSum[i][j] 表示从 (0, 0) 到 (i-1, j-1) 的子矩阵的和</span><br>            prefixSum[i][j] = prefixSum[i - <span class="hljs-number">1</span>][j] + prefixSum[i][j - <span class="hljs-number">1</span>] - prefixSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查询子矩阵的和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">querySubmatrixSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prefixSum, <span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用前缀和数组计算从 (row1, col1) 到 (row2, col2) 的子矩阵的和</span><br>    <span class="hljs-keyword">return</span> prefixSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - prefixSum[row1][col2 + <span class="hljs-number">1</span>] - prefixSum[row2 + <span class="hljs-number">1</span>][col1] + prefixSum[row1][col1];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例二维数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>        &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 前缀和数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; prefixSum;<br><br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-built_in">computePrefixSum</span>(matrix, prefixSum);<br><br>    <span class="hljs-comment">// 查询子矩阵的和</span><br>    <span class="hljs-type">int</span> row1 = <span class="hljs-number">1</span>, col1 = <span class="hljs-number">1</span>, row2 = <span class="hljs-number">2</span>, col2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">querySubmatrixSum</span>(prefixSum, row1, col1, row2, col2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sum of submatrix from (&quot;</span> &lt;&lt; row1 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; col1 &lt;&lt; <span class="hljs-string">&quot;) to (&quot;</span> &lt;&lt; row2 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; col2 &lt;&lt; <span class="hljs-string">&quot;) is: &quot;</span> &lt;&lt; sum &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>易错点</title>
    <link href="/2024/09/16/%E6%98%93%E9%94%99%E7%82%B9/"/>
    <url>/2024/09/16/%E6%98%93%E9%94%99%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>用标签块要用纯文本 不能放在代码框里</p><p>行内标签：</p><span class="label label-primary">text</span><p>便签：</p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h2 id="语法易错点："><a href="#语法易错点：" class="headerlink" title="语法易错点："></a>语法易错点：</h2><p>1.数组溢出，注意循环的&lt;&#x3D; 或者&lt;分界</p><p>2.if比较语句&#x3D;&#x3D;写成赋值语句&#x3D;</p><p>3.涉及到double运算的时候别习惯性写成int</p><p>4.char是单引号  int i&#x3D;stoi（string)</p><p>​    int i&#x3D;char-‘0’;</p><p>5.靠乘方的循环次数能用乘方表示就不要用移位</p><p>例：</p><p>出错版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;num&gt;((<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>);k++)&#123;&#125;<br>   k=k<span class="hljs-number">-1</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;...&#125;<br></code></pre></td></tr></table></figure><p>正确版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> step=<span class="hljs-number">1</span>;step&lt;num;step*=<span class="hljs-number">2</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><p>6.需要迭代的时候及时把if变成while：</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250305204635875.png" alt="image-20250305204635875"></p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250305204549129.png" alt="题目"></p><p>7.遍历方法</p><p>无条件遍历：循环</p><p>有条件遍历：自增自减+条件约束</p><p>8.背包问题</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20250306153408712.png" alt="image-20250306153408712"></p><p>其中选定物品i容量就被挤占，不选i可能容量够装别的物品，所以两者价值高低未知</p><p>9.回溯之 子集  VS 全排列</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p><p>回溯法递归的过程中，就那一个path，一个result,(一个used) 因此在dfs()里这些变量可传参可不传参（放于全局变量）：</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/9P%24%243K5F2OUTIX9GWY%7DE13N.png" alt="全排列"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2024/09/15/%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/09/15/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="位运算补充"><a href="#位运算补充" class="headerlink" title="位运算补充"></a>位运算补充</h2><p>1.给定一个数组，其中只有一种数出现了奇数次，其他都出现偶数次，怎么找到这一种数</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20240916154510883.png" alt="按位异或就是无进位相加 该图解释了异或运算与顺序无关"></p><p>eor与数组中全部的数都异或下来，出现偶数次的异或结果是0，奇数次的异或结果就是该数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> eor=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)&#123;<br>    eor^=arr[i];<br>&#125;<br>cout&lt;&lt;eor;<br></code></pre></td></tr></table></figure><p>2.给定一个数组，其中只有两种数出现了奇数次，其他都出现偶数次，怎么找到这两种数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> eor=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)&#123;<br>    eor^=arr[i];<br>&#125;<span class="hljs-comment">//最终eor=a^b,题目中说是两种数，因此eor！=0，即至少有一个数位是1</span><br><span class="hljs-type">int</span> rightone=eor&amp;(~eor<span class="hljs-number">+1</span>);<span class="hljs-comment">//位运算提取得到和eor同数位并保存最右边1的套路写法</span><br><br><span class="hljs-type">int</span> eor2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(arr[i]&amp;rightone==<span class="hljs-number">1</span>)&#123;<br>        eor2^=arr[i]<br>    &#125;<br>&#125;<span class="hljs-comment">//eor2找到的就是a或者b中的一个</span><br>cout&lt;&lt;eor2;<br>cout&lt;&lt;eor^eor2;<span class="hljs-comment">//就是另一个出现了奇数次的数</span><br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>简单选择排序和冒泡排序都是*<em>O(n</em>2)**，无论什么情况。(代码省略)</p><p>插入排序最差情况（初始是倒序）是<strong>O(n*2)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort3</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<span class="hljs-comment">//让0~i有序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;arr[j]&gt;arr[j<span class="hljs-number">+1</span>];j--)&#123;<span class="hljs-comment">//调整j+1(i)的位置</span><br>        <span class="hljs-built_in">swap</span>(arr[j<span class="hljs-number">+1</span>],arr[j]);<br>    &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对数器（替代在线测试平台）"><a href="#对数器（替代在线测试平台）" class="headerlink" title="对数器（替代在线测试平台）"></a>对数器（替代在线测试平台）</h2><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20240916211907273.png"></p><p>以插入排序为例子，方法b：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">comparator</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr,<span class="hljs-type">int</span> size)</span></span>&#123;<br><span class="hljs-built_in">sort</span>(arr,arr<span class="hljs-number">+6</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>生成随机数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyArray</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr1,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> rangeL,<span class="hljs-type">int</span> rangeR)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size,i++)&#123;<br>        arr[i]=<span class="hljs-built_in">rand</span>()%(rangeR-rangeL<span class="hljs-number">+1</span>)+rangeL;<span class="hljs-comment">//生成[rangeL,rangeR]的随机数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复制数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyArray</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr1,<span class="hljs-type">int</span> *arr2,<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>arr2[i]=arr1[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对数器测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> testTime, <span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> rangeL, <span class="hljs-type">int</span> rangeR)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> succeed = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-type">int</span> size = <span class="hljs-built_in">rand</span>() % maxSize + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 随机数组长度</span><br>        <span class="hljs-type">int</span> *arr1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<span class="hljs-comment">//开辟数组空间</span><br>        <span class="hljs-type">int</span> *arr2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>        <br>        <span class="hljs-comment">// 生成随机数组</span><br>        <span class="hljs-built_in">generateRandomArray</span>(arr1, size, rangeL, rangeR);<br>        <span class="hljs-built_in">copyArray</span>(arr1, arr2, size);  <span class="hljs-comment">// 复制到另一个数组</span><br><br>        <span class="hljs-comment">// 使用插入排序</span><br>        <span class="hljs-built_in">sort3</span>(arr1, size);<br>        <span class="hljs-comment">// 使用std::sort</span><br>        <span class="hljs-built_in">comparator</span>(arr2, size);<br><br>        <span class="hljs-comment">// 比较两种排序结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr1[j] != arr2[j]) &#123;<br>                succeed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span>[] arr1;<br>        <span class="hljs-keyword">delete</span>[] arr2;<br><br>        <span class="hljs-keyword">if</span> (!succeed) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Test failed!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (succeed) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;All tests passed!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 测试次数</span><br>    <span class="hljs-type">int</span> maxSize = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 最大数组大小</span><br>    <span class="hljs-type">int</span> rangeL = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 数组元素最小值</span><br>    <span class="hljs-type">int</span> rangeR = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 数组元素最大值</span><br><br>    <span class="hljs-built_in">test</span>(testTime, maxSize, rangeL, rangeR);<br><br></code></pre></td></tr></table></figure><h2 id="用递归找给定数组给定范围的最大值"><a href="#用递归找给定数组给定范围的最大值" class="headerlink" title="用递归找给定数组给定范围的最大值"></a>用递归找给定数组给定范围的最大值</h2><p><strong>实质：多叉树后续遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br><span class="hljs-type">int</span> mid,lmid,rmid;<br>    <span class="hljs-keyword">if</span>(L-R==<span class="hljs-number">0</span>)&#123;<br>       <span class="hljs-keyword">return</span> arr[L];<br>    &#125;<br>     <span class="hljs-keyword">else</span>&#123;<br>    mid=L+((R-L)/<span class="hljs-number">2</span>);<br>    lmid=<span class="hljs-built_in">process</span>(arr,L,mid);<br>    rmid=<span class="hljs-built_in">process</span>(arr,mid<span class="hljs-number">+1</span>,R);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lmid,rmid);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此类问题可以分为等量的子问题 满足master公式 其中O（）是子问题除了调用之外的时间复杂度：</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/1727773742560.png"></p><div class="note note-success">            <p>递归特点：</p><p>1.函数名称与内部调用名称相同</p><p>2.有临界条件</p>          </div><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    vector &lt;<span class="hljs-type">int</span>&gt;help;<br>    <span class="hljs-type">int</span> p=L;<br>    <span class="hljs-type">int</span> q=mid<span class="hljs-number">+1</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 合并两个子数组</span><br>    <span class="hljs-keyword">while</span> (p &lt;= mid &amp;&amp; q &lt;= R) &#123;<br>        <span class="hljs-keyword">if</span> (arr[p] &lt;= arr[q]) &#123;<br>            help.<span class="hljs-built_in">push_back</span>(arr[p]);<br>            p++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            help.<span class="hljs-built_in">push_back</span>(arr[q]);<br>            q++;<br>        &#125;<br>        <span class="hljs-comment">// 注意：i 的递增是在循环中自动发生的，因为我们在使用 help.push_back()</span><br>    &#125;<br><br>    <span class="hljs-comment">// 复制剩余的元素（如果有）</span><br>    <span class="hljs-keyword">while</span> (p &lt;= mid) &#123;<br>        help.<span class="hljs-built_in">push_back</span>(arr[p]);<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q &lt;= R) &#123;<br>        help.<span class="hljs-built_in">push_back</span>(arr[q]);<br>        q++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;help.<span class="hljs-built_in">size</span>();j++)&#123;<br>    arr[L+j]=help[j];&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br><span class="hljs-keyword">if</span>(R-L==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br> <span class="hljs-type">int</span> mid = L + (R - L) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 修正了计算 mid 的方式</span><br><span class="hljs-built_in">process</span>(arr,L,mid);<br><span class="hljs-built_in">process</span>(arr,(mid<span class="hljs-number">+1</span>),R);<br><span class="hljs-built_in">merge1</span>(arr,L,mid,R);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="小和问题（归并拓展）"><a href="#小和问题（归并拓展）" class="headerlink" title="小和问题（归并拓展）"></a>小和问题（归并拓展）</h3><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241004224904743.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> R)</span></span>&#123;<br><span class="hljs-comment">//产生小和</span><br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> p=L;<br><span class="hljs-type">int</span> q=mid<span class="hljs-number">+1</span>;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;help;<br><span class="hljs-keyword">while</span> (p&lt;(mid<span class="hljs-number">+1</span>) &amp;&amp;q&lt;R<span class="hljs-number">+1</span>)&#123;<br><br>    res=res+(arr[p]&lt;arr[q]?(arr[p]*(R-q<span class="hljs-number">+1</span>)):<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//接下来是正常的归并排序</span><br>    <span class="hljs-keyword">if</span> (arr[p]&lt;arr[q])&#123;<br>    help.<span class="hljs-built_in">push_back</span>(arr[p]);<br>        p++;<br><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>   help.<span class="hljs-built_in">push_back</span>(arr[q]);<br>    q++;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(p&lt;(mid<span class="hljs-number">+1</span>))&#123;<br>   help.<span class="hljs-built_in">push_back</span>(arr[p]);<br>   p++;<br>&#125;<br><span class="hljs-keyword">while</span>(q&lt;R<span class="hljs-number">+1</span>)&#123;<br>  help.<span class="hljs-built_in">push_back</span>(arr[q]);<br><br>   q++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xiaohe</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> mid=L+(R-L)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">xiaohe</span>(arr,L,mid)+<span class="hljs-built_in">xiaohe</span>(arr,mid<span class="hljs-number">+1</span>,R)+<span class="hljs-built_in">merge2</span>(arr,L,mid,R);<br><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector &lt;<span class="hljs-type">int</span>&gt;arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;;<br>cout&lt;&lt;<span class="hljs-built_in">xiaohe</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p><strong>快排3.0版本 随机选一个数做划分  时间：O(nlogn) 空间：O(logn)</strong></p><p>partition过程：</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241005161619429.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">partition1</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)&#123;<br>    <span class="hljs-type">int</span> i=L;<span class="hljs-comment">//i是当前位置</span><br>    <span class="hljs-type">int</span> p=L<span class="hljs-number">-1</span>;<span class="hljs-comment">//左区边界 界限打在属于左区的地方</span><br>    <span class="hljs-type">int</span> q=R;<span class="hljs-comment">//右区边界</span><br>    vector &lt;<span class="hljs-type">int</span>&gt;boundary;<br>    <span class="hljs-keyword">while</span>(i&lt;q)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&lt;arr[R])&#123;<br>                <span class="hljs-built_in">swap</span>(arr[i],arr[p<span class="hljs-number">+1</span>]);<br>                p++;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]&gt;arr[R])&#123;<br>            <span class="hljs-built_in">swap</span>(arr[i],arr[q<span class="hljs-number">-1</span>]);<br>            q--;&#125;<span class="hljs-keyword">else</span>&#123;<br>            i++;<br>     &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(arr[R],arr[q]);<br>    boundary.<span class="hljs-built_in">push_back</span>(p<span class="hljs-number">+1</span>);<br>    boundary.<span class="hljs-built_in">push_back</span>(q);<br>    <span class="hljs-keyword">return</span> boundary;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L&gt;=R)&#123;<span class="hljs-comment">//不容错漏</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>vector &lt;<span class="hljs-type">int</span>&gt;boundary;<br><span class="hljs-built_in">swap</span>(arr[L+<span class="hljs-built_in">rand</span>()%(R-L<span class="hljs-number">+1</span>)],arr[R]);<span class="hljs-comment">//R处是校对number</span><br>boundary=<span class="hljs-built_in">partition1</span>(arr,L,R);<br><span class="hljs-built_in">quicksort</span>(arr,L,boundary[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">quicksort</span>(arr,boundary[<span class="hljs-number">1</span>]<span class="hljs-number">+1</span>,R);<br><br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector &lt;<span class="hljs-type">int</span>&gt;arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-built_in">quicksort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>大根堆：所有子树的根就是子树最大的值</p><p>基本性质：<img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241006153119333.png"></p><p><strong>自下而上（heapinsert) 用户新加一个数组建堆 时间O(logN)</strong></p><p><strong>自上而下（heapfy) 把最大值移出</strong>（减小heapsize)<strong>调整堆 时间O(logN)</strong></p><h3 id="堆排序-时O-nlogn-空O-1"><a href="#堆排序-时O-nlogn-空O-1" class="headerlink" title="堆排序 时O(nlogn) 空O(1)"></a>堆排序 时O(<strong>nlogn</strong>) 空O(1)</h3><p>heapsize-数字个数</p><p>用户一个一个给数据（往上搭建大根堆）heapinsert时间O(nlogn)</p><p>用户一下子给全部数据（heapfy）时间O(n)</p><p>下述代码heapinsert heapfy 二选一 都可进行堆排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入下标为index的数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapinsert</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> index)</span></span>&#123;<br><span class="hljs-keyword">while</span>(arr[index]&gt;arr[(index<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>])&#123;<span class="hljs-comment">//不满足大根堆或者下标已经是0（堆最上方）</span><br>    <span class="hljs-built_in">swap</span>(arr[index],arr[(index<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]);<br>    index=(index<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//某数在index位置能否向下移动</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapfy</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> heapsize)</span></span>&#123;<br>    <span class="hljs-type">int</span> largest;<br>    <span class="hljs-keyword">while</span>(index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;heapsize)&#123;<span class="hljs-comment">//下方有孩子</span><br>        <span class="hljs-keyword">if</span>(index*<span class="hljs-number">2</span><span class="hljs-number">+2</span>&lt;heapsize)&#123;<br>           <span class="hljs-type">int</span> a=arr[index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&gt;arr[index*<span class="hljs-number">2</span><span class="hljs-number">+2</span>]?(index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>):(index*<span class="hljs-number">2</span><span class="hljs-number">+2</span>);<br>            largest=arr[a]&gt;arr[index]?a:index;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        largest=arr[index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&gt;arr[index]?(index*<span class="hljs-number">2</span><span class="hljs-number">+1</span>):index;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(largest==index)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">swap</span>(arr[largest],arr[index]);<br>        index=largest;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>堆排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapsort</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> heapsize)</span></span>&#123;<br> <span class="hljs-comment">//根据给定arr搭建堆</span><br> <span class="hljs-comment">//(1)log（n）</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=heapsize<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-built_in">heapfy</span>(arr,i,heapsize);<br> &#125;<br> <span class="hljs-comment">//(2)log(nlogn)</span><br>  <span class="hljs-comment">//for(int i=0;i&lt;heapsize;i++)&#123;</span><br>    <span class="hljs-comment">//heapinsert(arr,i);</span><br> <span class="hljs-comment">//&#125;</span><br> <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>],arr[heapsize<span class="hljs-number">-1</span>]);<br> heapsize--;<span class="hljs-comment">//最大值离开排序序列，安置在最后</span><br> <span class="hljs-built_in">heapfy</span>(arr,<span class="hljs-number">0</span>,heapsize);<span class="hljs-comment">//给新的arr[0]确认在该大根堆的位置</span><br> <span class="hljs-keyword">while</span>(heapsize&gt;<span class="hljs-number">0</span>)&#123;<br>     <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>],arr[heapsize<span class="hljs-number">-1</span>]);<br> heapsize--;<br> <span class="hljs-built_in">heapfy</span>(arr,<span class="hljs-number">0</span>,heapsize);<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector &lt;<span class="hljs-type">int</span>&gt;arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">heapsort</span>(arr,<span class="hljs-number">6</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>    cout&lt;&lt;arr[i]&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241006214353031.png" alt="堆结构例题"></p><p>排序过程中小根堆的heapsize保持在k个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 定义一个空的优先队列， 默认是大根堆,较大的优先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareIntegers</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<span class="hljs-comment">//把比较反过来</span><br>    &#125;<br>&#125;;<br><br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">heapsort</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;arr,<span class="hljs-type">int</span> k)&#123;<br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;, CompareIntegers&gt; p;<span class="hljs-comment">//小根堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++ )&#123;<br>    p.<span class="hljs-built_in">push</span>(arr[i]);<br>    &#125;<br>    vector &lt;<span class="hljs-type">int</span>&gt;brr;<br>    brr.<span class="hljs-built_in">push_back</span>(p.<span class="hljs-built_in">top</span>());<br><br>    <span class="hljs-keyword">while</span>(k&lt;arr.<span class="hljs-built_in">size</span>())&#123;<br>               p.<span class="hljs-built_in">pop</span>();<br>               p.<span class="hljs-built_in">push</span>(arr[k]);<br>               k++;<br>        brr.<span class="hljs-built_in">push_back</span>(p.<span class="hljs-built_in">top</span>());<br><br>    &#125;<br>    <span class="hljs-keyword">while</span> (!p.<span class="hljs-built_in">empty</span>())&#123;<br>        brr.<span class="hljs-built_in">push_back</span>(p.<span class="hljs-built_in">top</span>());<br>        p.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> brr;<br><br>&#125;<br><br><br><span class="hljs-comment">//测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>vector &lt;<span class="hljs-type">int</span>&gt;arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>&#125;;<span class="hljs-comment">//给定的数组必须是几乎有序数组</span><br><span class="hljs-type">int</span> k=<span class="hljs-number">6</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;brr=<span class="hljs-built_in">heapsort</span>(arr,k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:brr)&#123;<br>    cout&lt;&lt;i&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>别名：重载运算符  重载了<code>operator()</code>以允许像调用函数那样调用它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义一个比较器类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareIntegers</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 重载operator()，用于比较两个整数  </span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;  <br>        <span class="hljs-comment">// 这里我们定义了一个降序的比较器  </span><br>        <span class="hljs-keyword">return</span> a &gt; b;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;  <br>    CompareIntegers comp; <span class="hljs-comment">// 创建CompareIntegers的实例  </span><br>    <span class="hljs-comment">// 使用sort和自定义比较器对vector进行排序  </span><br>    <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), comp); <br>    <span class="hljs-comment">// 迭代输出排序后的结果  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> number : numbers) &#123;  <br>       cout &lt;&lt; number &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>用比较器把默认大根堆变成小根堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 定义一个空的优先队列， 默认是大根堆,较大的优先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareIntegers</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<span class="hljs-comment">//把比较反过来</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;, CompareIntegers&gt; p;<span class="hljs-comment">//小根堆</span><br>p.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>p.<span class="hljs-built_in">push</span>(<span class="hljs-number">9</span>);<br>p.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span>(!p.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;p.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>p.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/image-20241007013404160.png" alt="详细解释"></p><h2 id="不基于比较的排序（桶排序）"><a href="#不基于比较的排序（桶排序）" class="headerlink" title="不基于比较的排序（桶排序）"></a>不基于比较的排序（桶排序）</h2><p><strong>计数排序</strong></p><p>遍历一遍数据，a[n]&#x3D;数据是n的个数</p><p><strong>基数排序（桶排序）</strong></p><p>从右到左看数位 从左到右遍历数组 先入桶的先出桶</p><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/243d63e0280e7d12727e29f174a2809.jpg"></p><p>在代码层面，出桶过程&#x3D;&gt;辅助数组的填充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">weishu</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;arr)</span></span>&#123;<br><span class="hljs-comment">//得到最大数的位数</span><br><span class="hljs-type">int</span> maxnum=arr[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i]&gt;maxnum)&#123;<br>            maxnum=arr[i];<br>            index=i;<br><br>        &#125;<br><br>    &#125;<br>      <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(maxnum&gt;<span class="hljs-number">0</span>)&#123;<br><br>    maxnum/=<span class="hljs-number">10</span>;<br>    count++;<br>&#125;<br><br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//取出相应位数的数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdigit</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> j)</span></span>&#123;<span class="hljs-comment">//p的第几位（个十百）</span><br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=j;i++)&#123;<br>    k=p%<span class="hljs-number">10</span>;<br>    p=p/<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> k;&#125;<br><br><br><span class="hljs-comment">//出一次桶（生成辅助数组）排一次序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jishupaixu</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;arr)</span></span>&#123;<br><br><span class="hljs-type">int</span> digit=<span class="hljs-built_in">weishu</span>(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;digit;i++)&#123;<br>        <span class="hljs-type">int</span> tong[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:arr)&#123;<br>            <span class="hljs-type">int</span> index=<span class="hljs-built_in">getdigit</span>(num,i);<br>            tong[index]++;<br>        &#125;<br><br><span class="hljs-comment">//把桶修改成前缀和</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b =<span class="hljs-number">1</span>;b&lt;<span class="hljs-number">10</span>;b++)&#123;<br>        tong[b]=tong[b]+tong[b<span class="hljs-number">-1</span>];<br>      &#125;<br><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fuzhu</span><span class="hljs-params">(arr.size())</span></span>;  <span class="hljs-comment">// 辅助数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;c&gt;=<span class="hljs-number">0</span>;c--)&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-built_in">getdigit</span>(arr[c],i);<br>        <span class="hljs-keyword">if</span>(tong[j]<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>    fuzhu[tong[j]<span class="hljs-number">-1</span>]=arr[c];<br>    tong[j]--;&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;d&lt;arr.<span class="hljs-built_in">size</span>();d++)&#123;<br>    arr[d]=fuzhu[d];<span class="hljs-comment">//一次排序做完</span><br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector &lt;<span class="hljs-type">int</span>&gt; arr=&#123;<span class="hljs-number">107</span>,<span class="hljs-number">103</span>,<span class="hljs-number">201</span>,<span class="hljs-number">56</span>,<span class="hljs-number">24</span>,<span class="hljs-number">320</span>,<span class="hljs-number">10</span>,<span class="hljs-number">254</span>&#125;;<br><span class="hljs-built_in">jishupaixu</span>(arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:arr)&#123;<br>    cout&lt;&lt;i&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>下标和数值对应技巧：</p><p>for(int c&#x3D;arr.size()-1;c&gt;&#x3D;0;c–){<br>        int j&#x3D;getdigit(arr[c],i);<br>        if(tong[j]-1&gt;&#x3D;0){<br>    fuzhu[tong[j]-1]&#x3D;arr[c];<br>    tong[j]–;}<br>}</p><p><strong>多列几个数组，a数组的下标和b数组的数据构成联系</strong></p>          </div><h2 id="稳定性评估"><a href="#稳定性评估" class="headerlink" title="稳定性评估"></a>稳定性评估</h2><p>如果同样大小的数有跨越行径，则不稳定。如简单选择、堆排序，快排</p><p>稳定：冒泡排序、插入排序</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/Wendy888888888/image/main/NW7%7E_9%253OPKGNWLHYODMZ%5BX.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/14/hello-world/"/>
    <url>/2024/09/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
